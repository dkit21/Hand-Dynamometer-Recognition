#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.0 on Mon Jun 10 15:03:55 2019
#

import wx # gui core
import cv2
import numpy as np
import os
import glob
import argparse
import time
from statistics import stdev # std deviation
import itertools # accumulate list
import operator # accumulate list
import pickle #save train data
import tkinter as tk # gui
from operator import itemgetter
from tkinter import filedialog
import matplotlib.pyplot as plt

#DEFINE LEN OF NORMAL TEST DATA
result_text = ''
result_information = dict.fromkeys(['recognition_result', 'threshold', 'result', 'file', 'no'])

class MainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: MainFrame.__init__
        kwds["style"] = kwds.get("style", 0) | wx.CAPTION | wx.CLIP_CHILDREN | wx.CLOSE_BOX | wx.FRAME_NO_TASKBAR | wx.MINIMIZE_BOX | wx.SYSTEM_MENU
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((1070, 520))
        self.setting_btn = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("resources\\settings.bmp", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE)
        self.about_btn = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("resources\\about.bmp", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE)
        self.panel_1 = wx.Panel(self, wx.ID_ANY, style=wx.BORDER_SIMPLE)
        self.text_recognition_output = wx.TextCtrl(self, wx.ID_ANY, "00.0", style=wx.TE_AUTO_URL | wx.TE_CENTRE | wx.TE_READONLY)
        self.prev_btn = wx.Button(self, wx.ID_ANY, "< Previous", style=wx.BORDER_NONE)
        self.prev_btn.Disable()
        self.next_btn = wx.Button(self, wx.ID_ANY, "Next >", style=wx.BORDER_NONE)
        self.next_btn.Disable()
        self.text_result = wx.TextCtrl(self, wx.ID_ANY, "-", style=wx.TE_AUTO_URL | wx.TE_READONLY)
        self.capture_btn = wx.Button(self, wx.ID_ANY, "Capture", style=wx.BORDER_NONE)
        self.open_btn = wx.Button(self, wx.ID_ANY, "Open Folder", style=wx.BORDER_NONE)
        self.recog_btn = wx.Button(self, wx.ID_ANY, "Recognize", style=wx.BORDER_NONE)
        self.analyze_btn = wx.Button(self, wx.ID_ANY, "Analyze", style=wx.BORDER_NONE)
        self.analyze_btn.Disable()
        
        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.setting_btn_pressed, self.setting_btn)
        self.Bind(wx.EVT_BUTTON, self.about_btn_pressed, self.about_btn)
        self.Bind(wx.EVT_BUTTON, self.prev_btn_pressed, self.prev_btn)
        self.Bind(wx.EVT_BUTTON, self.next_btn_pressed, self.next_btn)
        self.Bind(wx.EVT_BUTTON, self.cap_btn_pressed, self.capture_btn)
        self.Bind(wx.EVT_BUTTON, self.open_btn_pressed, self.open_btn)
        self.Bind(wx.EVT_BUTTON, self.recog_btn_pressed, self.recog_btn)
        self.Bind(wx.EVT_BUTTON, self.analyze_btn_pressed, self.analyze_btn)

        # Define img_path
        self.img_path = ''
        self.current_img = 0

        # --------------------------- LOAD TRAINING DATA IN FOLDER TRAINED_IMG -----------------------------
        self.train_img = []
        # define folder trained data
        trainDir = 'trained_data/digits'
        # cari jumlah file pada folder trained
        trainedFileCount = len([name for name in os.listdir(trainDir) if os.path.isfile(os.path.join(trainDir, name))])
        # cek train data
        print('- Train data count:', trainedFileCount) 
        # if ada isi
        if trainedFileCount:
            # loop tiap file
            for i in range(trainedFileCount):
                with open('trained_data/digits/digit_' + str(i) + '.data', 'rb') as file:
                    # load data training
                    temp = pickle.load(file)
                # save ke list train_img
                self.train_img.append(temp)
        else:
            wx.MessageBox(message="Mohon lakukan pelatihan data sebelum menggunakan program.",
                                  caption='Train Data Not Found!',
                                  style=wx.OK | wx.ICON_INFORMATION)

        # --------------------------- LOAD TEST DATA (test_data.txt) -----------------------------
        # DEFINE VAR TEST DATA (test_data.txt)
##        normal_test_data = []
##        abnormal_test_data = []
        self.test_data =[] # bentuk list: [abn/normal[jumlah data[isi data]]]

        # LOAD (ABNORMAL/NORMAL)_TEST_DATA.TXT (HASIL TEST SEBELUMNYA), MAPPING KE LIST TEST_DATA
        # LOAD normal
        with open('trained_data/normal_test_data.txt', 'r') as f:
            for line in f:
                # mapping ke list, convert dari string ke float
                # pertama eleminasi space dan \n pake fungsi strip -> lalu split
                temp = list(map(float, line.strip(' \n').split()))
                # save ke test_data
                self.test_data.append(temp)
        # save panjang normal data
        self.count_normal_test = len(self.test_data)
        print('- count_normal_test: ', self.count_normal_test)
                
        # LOAD abnormal
        with open('trained_data/abnormal_test_data.txt', 'r') as f:
            for line in f:
                # mapping ke list, convert dari string ke float
                # pertama eleminasi space dan \n pake fungsi strip -> lalu split
                temp = list(map(float, line.strip(' \n').split()))
                # save ke test_data
                self.test_data.append(temp)

        # Append in Final List
##        self.test_data.extend([normal_test_data, abnormal_test_data])
                
        # CHECK TEST DATA
##        print('- normal: ', len(self.test_data[0]))
##        print('- abnormal: ', len(self.test_data[1]))
        print(self.test_data)
        print('- Test data count: ', str(len(self.test_data)))

    def __set_properties(self):
        # begin wxGlade: MainFrame.__set_properties
        self.SetTitle("Hand Dynamometer Recognition")
        _icon = wx.NullIcon
        _icon.CopyFromBitmap(wx.Bitmap("resources\\main_ico.ico", wx.BITMAP_TYPE_ANY))
        self.SetIcon(_icon)
        self.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.setting_btn.SetMinSize((50, 45))
        self.setting_btn.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.about_btn.SetMinSize((50, 45))
        self.about_btn.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.panel_1.SetMinSize((512, 288))
        self.panel_1.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.text_recognition_output.SetMinSize((512, 288))
        self.text_recognition_output.SetFont(wx.Font(190, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Agency FB"))
        self.prev_btn.SetMinSize((100, 35))
        self.prev_btn.SetBackgroundColour(wx.Colour(47, 47, 47))
        self.prev_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.prev_btn.SetFont(wx.Font(11, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        self.next_btn.SetMinSize((100, 35))
        self.next_btn.SetBackgroundColour(wx.Colour(47, 47, 47))
        self.next_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.next_btn.SetFont(wx.Font(11, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        self.text_result.SetMinSize((452, 27))
        self.text_result.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        self.capture_btn.SetMinSize((250, 40))
        self.capture_btn.SetBackgroundColour(wx.Colour(47, 47, 47))
        self.capture_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.capture_btn.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        self.open_btn.SetMinSize((250, 40))
        self.open_btn.SetBackgroundColour(wx.Colour(47, 47, 47))
        self.open_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.open_btn.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        self.recog_btn.SetMinSize((250, 40))
        self.recog_btn.SetBackgroundColour(wx.Colour(47, 47, 47))
        self.recog_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.recog_btn.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        self.analyze_btn.SetMinSize((250, 40))
        self.analyze_btn.SetBackgroundColour(wx.Colour(47, 47, 47))
        self.analyze_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.analyze_btn.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MainFrame.__do_layout
        grid_sizer_5 = wx.FlexGridSizer(8, 1, 0, 0)
        sizer_4 = wx.FlexGridSizer(1, 9, 0, 0)
        sizer_3 = wx.FlexGridSizer(1, 7, 0, 0)
        sizer_1 = wx.FlexGridSizer(1, 5, 0, 0)
        sizer_2 = wx.FlexGridSizer(1, 5, 0, 0)
        sizer_5 = wx.FlexGridSizer(1, 5, 0, 0)
        grid_sizer_5.Add((0, 5), 0, 0, 0)
        sizer_5.Add((10, 45), 0, 0, 0)
        sizer_5.Add((90, 45), 0, 0, 0)
        label_1 = wx.StaticText(self, wx.ID_ANY, "HAND DYNAMOMETER RECOGNITION", style=wx.ALIGN_CENTER)
        label_1.SetMinSize((854, 55))
        label_1.SetFont(wx.Font(24, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift"))
        sizer_5.Add(label_1, 0, 0, 0)
        sizer_5.Add(self.setting_btn, 0, 0, 0)
        sizer_5.Add(self.about_btn, 0, 0, 0)
        grid_sizer_5.Add(sizer_5, 1, wx.EXPAND, 0)
        sizer_2.Add((10, 10), 0, 0, 0)
        label_2 = wx.StaticText(self, wx.ID_ANY, "Input Image:", style=wx.ALIGN_CENTER)
        label_2.SetMinSize((512, 25))
        label_2.SetFont(wx.Font(14, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_2.Add(label_2, 0, 0, 0)
        sizer_2.Add((10, 10), 0, 0, 0)
        label_3 = wx.StaticText(self, wx.ID_ANY, "Recognition Output:", style=wx.ALIGN_CENTER)
        label_3.SetMinSize((512, 25))
        label_3.SetFont(wx.Font(14, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_2.Add(label_3, 0, 0, 0)
        sizer_2.Add((10, 10), 0, 0, 0)
        grid_sizer_5.Add(sizer_2, 1, wx.EXPAND, 0)
        sizer_1.Add((10, 10), 0, 0, 0)
        sizer_1.Add(self.panel_1, 1, wx.EXPAND, 0)
        sizer_1.Add((10, 10), 0, 0, 0)
        sizer_1.Add(self.text_recognition_output, 0, 0, 0)
        sizer_1.Add((10, 10), 0, 0, 0)
        grid_sizer_5.Add(sizer_1, 1, wx.EXPAND, 0)
        sizer_3.Add((10, 10), 0, 0, 0)
        sizer_3.Add(self.prev_btn, 0, wx.TOP, 5)
        self.label_jpg = wx.StaticText(self, wx.ID_ANY, "Image", style=wx.ALIGN_CENTER)
        self.label_jpg.SetMinSize((312, 35))
        self.label_jpg.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_3.Add(self.label_jpg, 0, wx.TOP, 12)
        sizer_3.Add(self.next_btn, 0, wx.TOP, 5)
        sizer_3.Add((10, 10), 0, 0, 0)
        label_5 = wx.StaticText(self, wx.ID_ANY, "Result: ")
        label_5.SetMinSize((52, 35))
        label_5.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_3.Add(label_5, 0, wx.TOP, 12)
        sizer_3.Add(self.text_result, 0, wx.ALL, 8)
        grid_sizer_5.Add(sizer_3, 1, wx.EXPAND, 0)
        grid_sizer_5.Add((100, 5), 0, 0, 0)
        sizer_4.Add((10, 10), 0, 0, 0)
        sizer_4.Add(self.capture_btn, 0, wx.TOP, 0)
        sizer_4.Add((12, 10), 0, 0, 0)
        sizer_4.Add(self.open_btn, 0, wx.TOP, 0)
        sizer_4.Add((10, 10), 0, 0, 0)
        sizer_4.Add(self.recog_btn, 0, wx.TOP, 0)
        sizer_4.Add((12, 10), 0, 0, 0)
        sizer_4.Add(self.analyze_btn, 0, wx.TOP, 0)
        sizer_4.Add((10, 10), 0, 0, 0)
        grid_sizer_5.Add(sizer_4, 1, wx.EXPAND, 0)
        grid_sizer_5.Add((0, 0), 0, 0, 0)
        self.SetSizer(grid_sizer_5)
        self.Layout()
        # end wxGlade

    def setting_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        tk.Tk().withdraw()
        DIR = filedialog.askdirectory(title="Select Train Data (Folder)")
        if DIR:
            try:
                # ----------------------------------------------------------------------
                # -------------------------- DATA TRAINING -----------------------------
                # ----------------------------------------------------------------------
                # DEFINE STRUCTURING ELEMENT*
                kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 15)) #kolom, baris*
                # TRAINING PROCESS
                self.train_img = []
                for i in range(10):
                    temp = []
                    for img in glob.glob(DIR+ "/" + str(i) + "/*.jpg"):
                        n = cv2.imread(img, 0)
                        # threshold train img
                        ret,n = cv2.threshold(n, 0, 255, cv2.THRESH_BINARY)
                        # flatten img
                        n = n.flatten()
                        temp.append(n)
                    self.train_img.append(temp)
                    # save file train (tiap digit 1 file) ke folder trained_digit
                    with open('trained_data/digits/digit_' + str(i) + '.data', 'wb') as file:
                        pickle.dump(self.train_img[i], file)

                # TRAIN DATA : train_img[10][i] bentuk list menyimpan value piksel secara flat
                # size each value 11397

                ##for i in range(10):
                ##    countImg.append(len([name for name in os.listdir(DIR+str(i))
                ##                if os.path.isfile(os.path.join(DIR+str(i), name))]))
                ##    print(countImg)

                wx.MessageBox(message="Pelatihan data berhasil!",
                                  caption='Training Complete',
                                  style=wx.OK | wx.ICON_INFORMATION)
            except:
                wx.MessageBox(message="Pelatihan data gagal!",
                                  caption='Training Failed',
                                  style=wx.OK | wx.ICON_ERROR)

    def about_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        frame = AboutFrame(None, wx.ID_ANY, "")
        frame.Show()

    def prev_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        self.current_img -= 1
        if self.current_img == 1:
            self.prev_btn.Disable()
        else:
            self.next_btn.Enable()
            self.prev_btn.Enable()
            
        temp_path = os.path.dirname(self.img_path)
        if self.img_path:
            self.label_jpg.SetLabel(str(self.current_img))
            self.img_path = temp_path + "/" + str(self.current_img-1) + ".jpg"
            # BUAT TAMPILIN KE PANEL
            self.bmp = wx.Image(self.img_path, wx.BITMAP_TYPE_JPEG)
            (w, h) = self.bmp.GetSize() # AMBIL SIZE IMG
            (wp, hp) = self.panel_1.GetSize()
            # RESIZE IMAGE SESUAI PANEL
            if h > hp:
                h = hp
            if w > wp:
                w = wp
            # SCALE + CONVERT TO BITMAP
            self.bmp = self.bmp.Scale(w,h).ConvertToBitmap()
            # TARO KE PANEL
            self.obj = wx.StaticBitmap(self.panel_1, -1, self.bmp,(0,0),(wp, hp))
            self.obj.Refresh()
        # ubah KOTAK RECOGNITION OUTPUT
        self.text_recognition_output.SetValue(result_information['recognition_result'][self.current_img-1])

    def next_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        self.current_img += 1
        if self.current_img == 5:
            self.next_btn.Disable()
        else:
            self.next_btn.Enable()
            self.prev_btn.Enable()
            
        temp_path = os.path.dirname(self.img_path)
        if self.img_path:
            self.label_jpg.SetLabel(str(self.current_img))
            self.img_path = temp_path + "/" + str(self.current_img-1) + ".jpg"
            # BUAT TAMPILIN KE PANEL
            self.bmp = wx.Image(self.img_path, wx.BITMAP_TYPE_JPEG)
            (w, h) = self.bmp.GetSize() # AMBIL SIZE IMG
            (wp, hp) = self.panel_1.GetSize()
            # RESIZE IMAGE SESUAI PANEL
            if h > hp:
                h = hp
            if w > wp:
                w = wp
            # SCALE + CONVERT TO BITMAP
            self.bmp = self.bmp.Scale(w,h).ConvertToBitmap()
            # TARO KE PANEL
            self.obj = wx.StaticBitmap(self.panel_1, -1, self.bmp,(0,0),(wp, hp))
            self.obj.Refresh()
        # ubah KOTAK RECOGNITION OUTPUT
        self.text_recognition_output.SetValue(result_information['recognition_result'][self.current_img-1])

    def cap_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        cam = cv2.VideoCapture(1) # set 0 default cam, 1 = logitech
        cam.set(3,1280)
        cam.set(4,720)
        
        while True:
            ret, frame = cam.read()
            frame = cv2.flip(frame, -1) # flip camera
            cv2.imshow("Cam", frame)
            k = cv2.waitKey(1)

            if k%256 == 27:
                # ESC pressed
                print("Escape hit, closing...")
                break
            elif k%256 == 32:
                i = 0
                t_end = time.time() + 5 # 5 detik
                while time.time() < t_end:  # do whatever you do
                    # STRING DATE-TIME BUAT NAMA IMG
                    ret, frame = cam.read()
                    frame = cv2.flip(frame, -1) # flip camera
                    cv2.imshow("Cam", frame)
                    time.sleep(1)
                    if not ret:
                        break
                    k = cv2.waitKey(1)
                    timestr = time.strftime("%d%m%Y_%H%M%S")
                    self.img_path = "cap_img/" + str(i) + ".jpg"
                    # SAVE IMG
                    cv2.imwrite(self.img_path, frame)
                    i=i+1
                # POPUP INFORMASI    
                wx.MessageBox(message="Pengambilan gambar berhasil!",
                                  caption='Capture Complete',
                                  style=wx.OK | wx.ICON_INFORMATION)
                break
        # CLEANING CAMERA
        cam.release()
        self.img_path = ''
        cv2.destroyAllWindows()

    def open_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        # ----------------------------------------------------------------------
        # --------------------------- OPEN FILE -----------------------------
        # ----------------------------------------------------------------------
        tk.Tk().withdraw()
        self.img_path = filedialog.askdirectory(initialdir=os.getcwd(),title="Select Testing Directory")
        if self.img_path:
            try:
                # BUAT TAMPILIN KE PANEL
                self.bmp = wx.Image(self.img_path + "/0.jpg", wx.BITMAP_TYPE_JPEG)
                (w, h) = self.bmp.GetSize() # AMBIL SIZE IMG
                (wp, hp) = self.panel_1.GetSize()
                # RESIZE IMAGE SESUAI PANEL
                if h > hp:
                    h = hp
                if w > wp:
                    w = wp
                # SCALE + CONVERT TO BITMAP
                self.bmp = self.bmp.Scale(w,h).ConvertToBitmap()
                # TARO KE PANEL
                self.obj = wx.StaticBitmap(self.panel_1, -1, self.bmp,(0,0),(wp, hp))
                self.obj.Refresh()
            except:
                self.text_result.SetValue("Folder not selected!")

    def recog_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        self.text_recognition_output.SetFont(wx.Font(190, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Agency FB"))
        outputSeries = []
        self.text_recognition_output.SetValue("")
        self.current_img = 0
        # ambil path file, diambil hanya dari working directory (pake function lib os.path.relpath)
        # jadi ....../cap_img/camry8/0.jpg
        filePath = os.path.relpath(self.img_path)
        file = open("recognition_result.txt", "a")
        file.write("File: " + filePath + "\nProcess Time: ")
        file.close()
        def recognition_func(path):
            start_time = time.time()
##            try:
            # ----------------------------------------------------------------------
            # --------------------------- DATA TESTING -----------------------------
            # ----------------------------------------------------------------------
##            alpha = float(2.5)
            # READ IMAGE
            imgOri = cv2.imread(self.img_path,1)
            imgOri = cv2.resize(imgOri,None,fx=0.63, fy=0.84, interpolation = cv2.INTER_AREA) #bagian EDIT*
##            # show
##            cv2.imshow('imgOri', imgOri)
            
##            # Adjust the exposure
##            imgOri = cv2.multiply(imgOri, np.array([alpha]))
##            debug_images.append(('Exposure Adjust', exposure_img))
            
            # COMPUTE GRAY IMAGE
            imgGray = cv2.cvtColor(imgOri.copy(), cv2.COLOR_BGR2GRAY)
##            # show
##            cv2.imshow('imgGray', imgGray)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()

            # SMOOTHING
            imgBlur = cv2.GaussianBlur(imgGray.copy(),(7,7),0)
##            # show
##            cv2.imshow('imgBlur', imgBlur)

            # TRESHOLD
            imgThresh = cv2.adaptiveThreshold(imgBlur.copy(), 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 121, 9)  # foto binary
##            # show
##            cv2.imshow('imgThresh', imgThresh)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()

            # -------------------- PROSES CROPPING AREA PANEL LED ----------------------
            # cari contours panel
            panelArray = []
            _, contours, _ = cv2.findContours(imgThresh.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            # setiap contours masukkan ke panelArray
            for i, c in enumerate(contours):
                area = cv2.contourArea(c)
                panelArray.append(area)
            # sort data contours
            sorteddata = sorted(zip(panelArray, contours), key=lambda x: x[0], reverse=True)
            #  find the nth largest contour [n-1][1], in this case 2
            panelarea = sorteddata[1][1]
            # bounding rect
            x, y, w, h = cv2.boundingRect(panelarea)
            
            ## di gunakan jika ingin draw contour yang didapat
##            cv2.drawContours(imga, panelarea, -1, (0, 255, 0), 2)
            
            # DRAW AREA
            imgContour = imgOri.copy()
            cv2.rectangle(imgContour, (x, y), (x+w, y+h), (0,0,0), 1)
##            # show
##            cv2.imshow('imgContour', imgContour)

            # CROP PANEL
            imgPanel = imgContour.copy()[y:y+h, x:x+w]
##            # show
##            cv2.imshow('imgPanel', imgPanel)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()
            
            ##cv2.rectangle(img, (x, y), (x+w, y+h), (0,255,0), 2)
            # crop panel, set + - menyesuaikan kondisi
##            panelRGB = img[y+100:y+h-120, x+140:x+w-120] #[y_atas:y_bawah , x_kiri:x_kanan]*
##            panelGray = imgCCL[y+100:y+h-120, x+140:x+w-120] # EDIT*
##            ret,panelGray = cv2.threshold(panelGray.copy(), 0, 255, cv2.THRESH_BINARY)

            # SAVE IMG PANEL
            panel_img = os.path.basename(self.img_path)
            cv2.imwrite('temp/Panel_' + panel_img, imgPanel)

            # THRESHOLD PANEL
            imgGrayPanel = cv2.cvtColor(imgPanel, cv2.COLOR_BGR2GRAY)
            imgThreshPanel = cv2.adaptiveThreshold(imgGrayPanel, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 121, 9)
            cv2.imwrite('temp/threshPanel.jpg', imgThreshPanel)
##            # show
##            cv2.imshow('imgThreshPanel', imgThreshPanel)

##            # CROP AREA YANG GA PERLU
            imgPanelCropped = imgThreshPanel
##            h, w = imgThreshPanel.shape
##            imgPanelCropped = imgThreshPanel[10:h-90, 200:w-135] #[y_atas:y_bawah , x_kiri:x_kanan]*
##            cv2.imwrite('temp/PanelCropped.jpg', imgPanelCropped)
##            cv2.imshow('imgPanelCropped', imgPanelCropped)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()
##            
####            _, contours, _ = cv2.findContours(imgThresh.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
####            for contour in contours:
####                (x,y,w,h) = cv2.boundingRect(contour)
####                cv2.rectangle(imga, (x,y), (x+w,y+h), (0,255,0), 2)
####
######            cv2.drawContours(imga, contours, -1, (0, 255, 0), 2)
####            
####            cv2.imshow('imgaa', imga)
####            cv2.waitKey(0)
####            cv2.destroyAllWindows()

            # -------------------------- PROSES CCL -------------------------------
            imgPanelCropped = cv2.bitwise_not(imgPanelCropped)
##            cv2.imshow('imgPanelCropped2', imgPanelCropped)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()
            # cari seluruh connected component (objek putih)
            nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(imgPanelCropped, connectivity=8)
            #connectedComponentswithStats yields every seperated component with information on each of them, such as size
            #the following part is just taking out the background which is also considered a component, but most of the time we don't want that.
            sizes = stats[1:, -1]; nb_components = nb_components - 1
            # minimum size of particles we want to keep (number of pixels)
            #here, it's a fixed value, but you can set it as you want, eg the mean of the sizes or whatever
            min_size = 1000   #EDIT *
            #your answer image
            imgCCL = np.zeros((output.shape))
            # untuk setiap component di img, disimpan yang lebih besar dari min_size
            for i in range(0, nb_components):
                if sizes[i] >= min_size:
                    imgCCL[output == i + 1] = 255
            # img hasil CCL
            imgCCL = cv2.convertScaleAbs(imgCCL)
            imgCCL = cv2.bitwise_not(imgCCL)
            # show hasil img
##            cv2.imshow('imgCCL', imgCCL)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()
            
            # ------------------ PROSES CLOSING (MERAPATKAN PIKSEL)--------------------
            # DEFINE STRUCTURING ELEMENT*
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 5)) #kolom, baris*
            # merapatkan gambar (fill holes)
            imgMorph = cv2.erode(imgCCL, kernel, iterations=3)
##            imgMorph = cv2.morphologyEx(imgThreshPanel, cv2.MORPH_CLOSE, kernel)
            # show
##            cv2.imshow('imgMorph', imgMorph)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()

            # ------------------------- CARI POTENTIAL DIGIT DARI AREA PANEL ------------------------      
            # cari contours digit
            imgDigit = cv2.bitwise_not(imgMorph)
##            cv2.imshow('imgDigit', imgDigit)
##            cv2.waitKey(0)
##            cv2.destroyAllWindows()

            _, contours, _ = cv2.findContours(imgDigit, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            print(len(contours))
            
##            cv2.drawContours(imgDigit, panelarea, -1, (0, 255, 0), 2)
##            cv2.imshow('imgDigit', imgDigit)

            # Fungsi Sorting Contours Kiri ke Kanan
            def sort_contours(cnts):
                    # initialize the reverse flag and sort index
                    reverse = False
                    i = 0
                    # construct the list of bounding boxes and sort them from top to bottom
                    boundingBoxes = [cv2.boundingRect(c) for c in cnts]
                    (cnts, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),
                            key=lambda b:b[1][i], reverse=reverse))
                    # return the list of sorted contours and bounding boxes
                    return (cnts, boundingBoxes)
                
            # Manggil fungsi
            contours, _ = sort_contours(contours)

            # declare buat save img
            potential_digits = []
            total_digit_height = 0
            total_digit_y = 0

            # Aspect ratio non 1 digit
            non_one_ratio = 0.6
            # Aspect ratio "1" digit
            one_ratio= 0.3
            # Buffer aspect
            aspect_buffer = 0.16
            
            # LOOPING #1 Fungsi loop contour, draw, crop, resize, save
            for contour in contours:
                x,y,w,h = cv2.boundingRect(contour)
                
                # hitung aspecet n size tiap contour
                aspect = float(w)/h
                print('aspect: ', str(aspect))
                size = w*h
                print('size,y,h: ', str(size), str(y), str(h))

                # Kalo width lebih besar dari height, abaikan
                if w > h:
                    continue
                # cek apakah sesuai estimasi rasio dan size yang telah ditentukan
                if ((size > 20000 and aspect >= non_one_ratio - aspect_buffer and aspect <= non_one_ratio + aspect_buffer) or
                    (size > 10000 and aspect >= one_ratio - aspect_buffer and aspect <= one_ratio + aspect_buffer)):
                    # sum height dan y position untuk jalanin avg sebagai patokan
                    total_digit_height += h
                    total_digit_y += y
                    potential_digits.append(contour)
                    
            # cek jumlah potential digit
            print('Potential Digit: ', str(len(potential_digits)))
            # declare avg var height n Y
            avgDigitHeight = 0
            avgDigitY = 0
            potentialDigitsCount = len(potential_digits)
            # jika ada potential digit
            if potentialDigitsCount > 0:
                # hitung rata"
                avgDigitHeight = float(total_digit_height)/potentialDigitsCount
                avgDigitY = float(total_digit_y)/potentialDigitsCount

            # print cek avg
            print('avgDigitHeight: ', str(avgDigitHeight))
            print('avgDigitY: ', str(avgDigitY))

            # ------------------------- EKSTRAK POTENTIAL DIGIT ------------------------
            test_img = []
            # Declare counter
            i = 0
            # Copy RGB img panel
            imgDetectedDigit = imgPanel.copy()
            
            # LOOPING #2 Loop potential digits apakah sesuai kriteria untuk di mark sebagai digit
            for digit in potential_digits:
                x,y,w,h = cv2.boundingRect(digit)
                # cek contour sesuai avg atau tidak
                if h <= avgDigitHeight * 1.2 and h >= avgDigitHeight * 0.5 and y <= avgDigitY * 1.35 and y >= avgDigitY * 0.5:
                    # draw contour untuk ditampilin
                    imgDigit = cv2.rectangle(imgDetectedDigit, (x,y),(x+w,y+h),(0,255,0),2)
                    # save img per digit
                    tempDigit = imgMorph.copy()[y:y+h, x:x+w]
                    # resize 50 x 155
                    tempDigit = cv2.resize(tempDigit, (50, 155))
                    # save img di folder temp
                    cv2.imwrite("temp/" + str(i)+".jpg", tempDigit)
                    # simpan di flatten array
                    test_img.append(tempDigit.flatten())
                    # print flatten array for check
                    print('Flatten detected_digit-' + str(i) +': ', test_img[i].shape)
                # keep track counter i
                i += 1
            # show img dengan contour digit
            cv2.imshow('imgDigit', imgDigit)
            cv2.waitKey(0)
            cv2.destroyAllWindows()

            ## RESULT TILL THIS PROCESS:
            ## test_img = flatten array (harusnya size 2/3) misal:
            ## test_img[o] = (1,2,3,4,5,......,n) (n = width*height)
            ## print(test_img[0].shape) = (7750,)

            ## RESULT TRAIN & TEST :
            ## TRAIN = train_img, size 10,i (i=jumlah image tiap folder) flatten array
            ## TEST  = test_img, size 3 flatten array
            ## test_img[0] = angka 2
            ## test_img[1] = angka 9
            ## test_img[2] = angka 0
            ## panel led = 0 9 2

            # --------------------------------------------------------------------------
            # ---------------------------------- KNN -----------------------------------
            # --------------------------------------------------------------------------

            k = 1
            # DEFINE DICT FOR EACH DIGIT DISTANCE
            distDigit = []
            eucdDigit = []
            if potentialDigitsCount == 2: 
                knnDigit = [[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0]]
            if potentialDigitsCount == 3:
                knnDigit = [[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0]]
##            try:
            # CARI NILAI EUCLIDEAN DISTANCE
            for test in range(len(test_img)): #3
                tempDigit = []
                for train in range(len(self.train_img)): #10
                    print ('--------terhadap' + str(train) + '----------')
                    for i in range(len(self.train_img[train])): #sesuai isi 4/1/1/1/...
                        # Euclidean Distance
                        temp = np.linalg.norm(np.array(test_img[test])-np.array(self.train_img[train][i]))
                        print(temp)
                        # simpan dalam list distDigit
                        tempDigit.append([str(train), temp])
                tempDigit = sorted(tempDigit, key=itemgetter(1)) 
                eucdDigit.append(tempDigit)

            # print list
            for i in range(len(eucdDigit)): #3 eucdDigit dalam bentuk 3d list (eucdDigit[][][])
                print(eucdDigit[i])
                print('-------------------')

            # tampung hasil euclidean sesuai k
            result = np.zeros((3,10))
            KNNEucDis = []

            # CARI NILAI ED SESUAI K
            for h in range(len(eucdDigit)): #3
                for i in range(k): #10 = sesuai parameter k
                    for j in range(10): #10 = jumlah digit
                        tempSum = 0
                        if eucdDigit[h][i][0] == str(j):
                            knnDigit[h][j] = knnDigit[h][j] + 1
                            result[h][j] = result[h][j] + eucdDigit[h][i][1]
                print('HASIL DIGIT KE-' + str(h))
                print(knnDigit[h])

            # INISIALISASI ANGKA
            for i in range(len(result)):
                temp = []
                for j in range(len(result[i])):
                    temp.append([str(j), result[i][j]])
                KNNEucDis.append(temp)
                print('HASIL SUM EUCLIDEAN DISTANCE DIGIT KE-' + str(i))
                print(KNNEucDis[i])
                # Hasil KNNEucDis berupa list [[['0', 5930.412689834451], ['1', 0.0],....,['9', 0.0]], [[......]], [[.....]]]


            # PILIH KATEGORI TERBESAR, CARI NILAI ED PALING KECIL, STORE NILAI PENGENALAN DALAM STRING
            print('################################################')
            recog = ''
            for i in range(len(knnDigit)): #3
                tempKnnResult = []
                # cari nilai kategori terbesar di setiap file
                index, value = max(enumerate(knnDigit[i]), key=itemgetter(1)) #knnDigit[i] masi rancu karena knnDigit hrusnya dari length knnDigit
                for j in range(len(knnDigit[i])): #10
                    if knnDigit[i][j] == value:
                        # tampung sementara nilai dari kategori terbesar (disini 2)
                        tempKnnResult.append(KNNEucDis[i][j])
                tempKnnResult = sorted(tempKnnResult, key=itemgetter(1))
                # simpan / append ke string recog
                recog = recog + tempKnnResult[0][0]
                print(tempKnnResult)

            # TAMPILKAN ANGKA
            print ('\n\nRECOGNITION RESULT :')
            # cek kalo input cuma 2 digit atau 3 digit, letak koma disesuaikan
            if len(recog) == 2:
                recog = recog[:1] + '.' + recog[1:]
            else:
                recog = recog[:2] + '.' + recog[2:]
            print (recog)
##                    sfont = 25

            # MUNCULIN KE PANEL DAN RESIZE
            # BUAT TAMPILIN KE PANEL
            self.bmp = wx.Image(self.img_path, wx.BITMAP_TYPE_JPEG)
            (w, h) = self.bmp.GetSize() # AMBIL SIZE IMG
            (wp, hp) = self.panel_1.GetSize()
            # RESIZE IMAGE SESUAI PANEL
            if h > hp:
                h = hp
            if w > wp:
                w = wp
            # SCALE + CONVERT TO BITMAP
            self.bmp = self.bmp.Scale(w,h).ConvertToBitmap()
            # TARO KE PANEL
            self.obj = wx.StaticBitmap(self.panel_1, -1, self.bmp,(0,0),(wp, hp))
            self.obj.Refresh()

            # SIMPEN OUTPUT SERIES (HASIL SEMUA RECOGNITION KEDALAM 1 LIST)
            outputSeries.append(recog)
            # SIMPEN KE GLOBAL DICT
            result_information['recognition_result'] = outputSeries
            print(result_information['recognition_result'])

            # BIND KE TEXT CONTROL DI GUI
##                    self.text_ctrl_1.SetFont(wx.Font(sfont, wx.MODERN, wx.NORMAL, wx.BOLD, 0, ""))
            self.text_recognition_output.SetValue(recog)
                
            #MEASURE TIME
            print("--- %s seconds ---" % (time.time() - start_time))
            # WRITE KE TXT
            with open('recognition_result.txt', 'a') as file:
                file.write(str(time.time()-start_time) + " ")
            
        # START RECOG
        imgfile = next(os.walk(self.img_path))[2]
        temp_path = self.img_path
        if self.img_path:
            for countImg in range(len(imgfile)):
                # counter for next and previous
                self.current_img += 1
                print('current_img: ', self.current_img)
                if self.current_img == 1:
                    self.prev_btn.Disable()
                if self.current_img == 5:
                    self.next_btn.Disable()
                else:
                    self.prev_btn.Enable()
                    self.next_btn.Enable()
                self.label_jpg.SetLabel(str(self.current_img))
                self.img_path = temp_path + "/" + str(countImg) + ".jpg"
                #recog function
                recognition_func(self.img_path)
                wx.Yield()
                
        ## FUNGSI TAMPILIN PLOT INPUT
        # outputSeries jadiin float
        y = list(map(float, outputSeries))
        # range image
        leng_y = len(y)
        x = np.arange(1, leng_y+1, 1)
        width = 0.6
        # MENAMPILKAN PLOT
        fig, ax = plt.subplots(figsize=(4.92, 3.69), dpi=100)
        rects1 = ax.bar(x, y, width, color='b')
        ax.set_ylim(0,max(y)+6)
        ax.set_ylabel('Hasil Pengenalan')
        ax.set_xlabel('Citra Detik ke-')
        ax.set_title('Grafik Nilai Hasil Pengenalan LED (Citra Input)')
        ax.set_xticks(x) # set the position of the x ticks
        ax.set_xticklabels(('1', '2', '3', '4', '5', '6', '7', '8', '9', '10'))
        # FUNGSI ADD LABEL TIAP BAR
        def autolabel(rects):
            # attach some text labels
            for rect in rects:
                height = rect.get_height()
                ax.text(rect.get_x() + rect.get_width()/2., 1*height,
                        '%.1f' % float(height),
                        ha='center', va='bottom')
        autolabel(rects1)
        plt.grid(True)
        plt.tight_layout()
        # SAVE PLOT
        plt.savefig('temp/plot_input.jpg')
        
        # print list output
        print(outputSeries)
        
        ## SAVE OUTPUT SERIES KE RECOGNITION RESULT
        timestr = time.strftime("%d-%m-%Y %H:%M:%S")
        with open('recognition_result.txt', 'a') as file:
            file.write("\nDate: " + timestr + "\nResult: ")
            for i in outputSeries:
                file.write(str(i) + " ")
            file.write("\n---------------------\n")

##        time.sleep(3)
        self.analyze_btn.Enable()

        # ----------------------------------------------------------------------
        # ------------ ITERATIVE INVARIANT AREA HISTOGRAM MATCHING -------------
        # ----------------------------------------------------------------------
        input_data = y # copy output list yang uda jadi float (y yg atas)
        print('- test_data: ', self.test_data)
        print('- input_data: ', input_data)
        # DEFINE LIST PELUANG TEST DAN INPUT DATA
        density_test = []
        density_input = []

        # ---------------------------- HITUNG PELUANG HISTOGRAM -------------------------
        # DENSITY TEST DATA
        # karena bentuk test_data = [[1,2,3,..],[1,2,3,...],[...],[...]]
        for i in range(len(self.test_data)): # loop untuk panjang test data (jumlah list)
            tempList = []
            for j in range(len(self.test_data[i])): # loop untuk isi setiap list
                # cari peluang setiap data (nilai ke-i/jumlah seluruh nilai)
                temp = self.test_data[i][j]/sum(self.test_data[i])
                tempList.append(temp)
            # round list 4 angka dibelakang koma
##            tempList = ['%.4f' % elem for elem in tempList]
            # save ke final list ini
            density_test.append(tempList)
        # cek list output:
        # - density_test_data: [['0.1215', '0.1947', '0.2305', '0.2671', '0.1862'],
        # ['0.2577', '0.2471', '0.1935', '0.1630', '0.1387'], ['1.0000']] (len = 3)
        print('- density_test: ', density_test)

        # DENSITY INPUT DATA
        # karena bentuk input_data [1,2,3,4,5]
        for i in range(len(input_data)): #loop berdasarkan panjang input data (hrusnya 5)
            # hitung peluang setiap data
            temp = input_data[i]/sum(input_data)
            # save ke final list
            density_input.append(temp)
        # print list
        print('- density_input: ', density_input)
                
        # ---------------------------- KUMULATIF PELUANG TIAP HISTOGRAM -------------------------
        # DEFINE LIST KUMULATIF PELUANG TEST DAN INPUT DATA
        cumulative_density_test = []
        cumulative_density_input = []

        # function itertools.accumulate
        def accumulate(iterable, func=operator.add):
            # 'Return running totals'
            # accumulate([1,2,3,4,5]) --> 1 3 6 10 15
            # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120
            it = iter(iterable)
            total = next(it)
            yield total
            for element in it:
                total = func(total, element)
                yield total
                
        # CUMULATIVE DENSITY TEST DATA
        for i in range(len(self.test_data)): # loop untuk panjang test data (jumlah list)
            # hitung akumulasi list dengan function accumulate
            tempList = list(accumulate(density_test[i]))
            cumulative_density_test.append(tempList)
        # print list
        # - cumulative_density_test:  [[29.9, 77.8, 134.5, 200.2, 246.0],
        # [47.65, 93.35, 129.13, 159.28, 184.93], [6.7], [6.3]]
        print('- cumulative_density_test: ', cumulative_density_test)

        # CUMULATIVE DENSITY INPUT DATA
        cumulative_density_input = list(accumulate(density_input))
        # print list
        print('- cumulative_density_input: ', cumulative_density_input)

        # ---------------------------- DISTRIBUSI KUMULATIF (CARI SELISIH TERDEKAT IMG REF(test) dengan IMG INPUT -------------------------
        # DEFINE LIST
        closest_position = [] # format: [[closest position sama cumulative_density_input ke-],[...],[...]]

        # DISTRIBUSI KUMULATIF, ilustrasi:
        # Data latih ke- |  Data input
        # 1([1,2,3,4,5)  |  1 -> 1
        # 2([_,_,_,_,_)  |  1 -> 2
        # 3([_,_,_,_,_)  |  1 -> 3
        # 4([_,_,_,_,_)  |  1 -> 4
        # Data input [1,2,3,4,5] dibandingkan peluangnya dengan semua test_data
        for len_list in range(len(cumulative_density_test)): # loop untuk banyaknya list test data[[..],[..],..,[..]]
            tempMin=[]
            # loop untuk isi setiap list test data [...] (*hrusnya 5)
            for isi_list_test in range(len(cumulative_density_test[len_list])):
##                # loop untuk isi input_data
##                for len_list_input in range(len(cumulative_density_input)):
                # get index position of list for the closest number
                min_diff = min(range(len(cumulative_density_input)), key=lambda i:abs(cumulative_density_input[i]-cumulative_density_test[len_list][isi_list_test]))
                tempMin.append(min_diff)
            # save ke final list
            closest_position.append(tempMin)
        # print final list
        # - closest_position:  [[0, 0, 1, 3, 4], [0, 1, 1, 3, 4], [0, 0, 1, 3, 4]]
        print('- closest_position: ', closest_position)

        # ---------------------------- HISTOGRAM MATCHING -------------------------
        # DEFINE LIST
        histogram_matching = []
        
        # HISTOGRAM MATCHING
        # loop untuk panjang list closest_position (banyak test data) [[..],[..],[..],....,[..]]
        for i in range(len(closest_position)):
            tempHistogram = [0]*len(input_data) # list sum setiap posisi yang sama
            # loop untuk isi tiap list [1,2,3,4,5] *harusnya 5
            for j in range(len(closest_position[i])):
                print('closest_position untuk test data ke-: ', j)
                # loop untuk panjang temp histogram yang nyimpen akumulasi sum
                for k in range(len(tempHistogram)):
                    # if closest position cocok sama akumulasi ke k
                    if closest_position[i][j] == k:
                        print('closest_position: ' + str(closest_position[i][j]) + ' -> density test ke-: ' + str(k))
                        # maintain akumulasi, tiap closest position match sama index = dijumlah/terus di sum up
                        tempHistogram[k] += density_test[i][j]
                        print('temp Histogram: ', tempHistogram)
            # save ke final list
            histogram_matching.append(tempHistogram)
        # print final list, OUTPUT:
        # - histogram_matching:  [[0.316260162601626, 0.2304878048780488, 0, 0.26707317073170733, 0.18617886178861787],
        # [0.1933734939759036, 0.3921686746987951, 0, 0.2301204819277108, 0.18433734939759033],
        # [0.3574788334901223, 0.21260583254938853, 0, 0.2116650987770461, 0.21825023518344308]]
        print('\n- histogram_matching: ', histogram_matching)

        # ---------------------------- IMAGE DIFFERENCING -------------------------
        # DEFINE FINAL LIST
        image_differencing = []

        # CALCULATE IMAGE DIFFERENCING
        for i in range(len(density_test)):
            tempList = []
            for j in range(len(density_test[i])):
                temp = abs(density_test[i][j]-histogram_matching[i][j])
                tempList.append(temp)
            # save ke final list
            image_differencing.append(tempList)
        # print final list
        print('- image_differencing: ', image_differencing)

        # ---------------------------- (FINAL) STD DEVIATION AND DETERMINE THRESHOLD -------------------------
        # DEFINE FINAL LIST
        threshold = []
        
        # CALCULATE MEAN
        # loop list image_differencing
        for img_diff in image_differencing:
            # call function stdev from statistic module
            tempDev = stdev(img_diff)
            # save ke final list
            threshold.append(tempDev)
        # print mean
        print('- threshold: ', threshold)

        # MINIMUM THRESHOLD
        # find minimum threshold in list
        min_threshold_idx, min_threshold_value = min(enumerate(threshold), key=operator.itemgetter(1))
        # pembulatan 4 angka dibelakang
        min_threshold_value = round(min_threshold_value,4)
        # print FINAL THRESHOLD
        print('- Final Threshold: ', min_threshold_value)

        ## FUNGSI TAMPILIN PLOT REFERENCE
        # outputSeries jadiin float
        y = self.test_data[min_threshold_idx]
        # range image
        leng_y = len(y)
        x = np.arange(1, leng_y+1, 1)
        width = 0.6
        # MENAMPILKAN PLOT
        fig, ax = plt.subplots(figsize=(4.92, 3.69), dpi=100)
        rects1 = ax.bar(x, y, width, color='b')

        ax.set_ylim(0,max(y)+6)
        ax.set_ylabel('Hasil Pengenalan')
        ax.set_xlabel('Citra Detik ke-')
        ax.set_title('Grafik Nilai Hasil Pengenalan LED (Citra Referensi)')
        ax.set_xticks(x) # set the position of the x ticks
        ax.set_xticklabels(('1', '2', '3', '4', '5', '6', '7', '8', '9', '10'))

        # FUNGSI ADD LABEL TIAP BAR
        def autolabel(rects):
            # attach some text labels
            for rect in rects:
                height = rect.get_height()
                ax.text(rect.get_x() + rect.get_width()/2., 1*height,
                        '%.1f' % float(height),
                        ha='center', va='bottom')
        autolabel(rects1)
        plt.grid(True)
        plt.tight_layout()
        # SAVE PLOT
        plt.savefig('temp/plot_reference.jpg')

        ## FUNGSI TAMPILIN PLOT HISTOGRAM MATCHING
        # outputSeries jadiin float
        y = histogram_matching[min_threshold_idx]
        # range image
        leng_y = len(y)
        x = np.arange(1, leng_y+1, 1)
        width = 0.6
        # MENAMPILKAN PLOT
        fig, ax = plt.subplots(figsize=(4.92, 3.69), dpi=100)
        rects1 = ax.bar(x, y, width, color='r')

        ax.set_ylim(0,max(y)*1.6)
        ax.set_ylabel('Nilai')
        ax.set_xlabel('Citra Detik ke-')
        ax.set_title('Histogram Matching')
        ax.set_xticks(x) # set the position of the x ticks
        ax.set_xticklabels(('1', '2', '3', '4', '5', '6', '7', '8', '9', '10'))

        # FUNGSI ADD LABEL TIAP BAR
        def autolabel(rects):
            # attach some text labels
            for rect in rects:
                height = rect.get_height()
                ax.text(rect.get_x() + rect.get_width()/2., 1*height,
                        '%.4f' % float(height),
                        ha='center', va='bottom')
        autolabel(rects1)
        plt.grid(True)
        plt.tight_layout()
        # SAVE PLOT
        plt.savefig('temp/plot_histogram_matching.jpg')

        # KESIMPULAN HASIL
        print('simpulan hasil count normal test data: ', self.count_normal_test)
        if min_threshold_idx < self.count_normal_test:
            result_information['result'] = 'NORMAL'
            result_information['threshold'] = str(min_threshold_value)
            result_information['file'] = 'Normal Test Data'
            result_information['no'] = str(min_threshold_idx+1)
            print('- KESIMPULAN: NORMAL')
        else:
            result_information['result'] = 'ABNORMAL'
            result_information['threshold'] = str(min_threshold_value)
            result_information['file'] = 'Abnormal Test Data'
            result_information['no'] = str((min_threshold_idx-self.count_normal_test)+1)
            print('- KESIMPULAN: ABNORMAL')

        # SET KE TEXT_RESULT
        self.text_result.SetValue(result_information['result'])

    def analyze_btn_pressed(self, event):  # wxGlade: MainFrame.<event_handler>
        frame = DetailFrame(None, wx.ID_ANY, "")
        frame.Show()

# end of class MainFrame

class AboutFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: AboutFrame.__init__
        kwds["style"] = kwds.get("style", 0) | wx.CAPTION | wx.CLIP_CHILDREN | wx.CLOSE_BOX | wx.SYSTEM_MENU
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((680, 376))

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: AboutFrame.__set_properties
        self.SetTitle("About")
        _icon = wx.NullIcon
        _icon.CopyFromBitmap(wx.Bitmap("resources\\about_ico.ico", wx.BITMAP_TYPE_ANY))
        self.SetIcon(_icon)
        self.SetBackgroundColour(wx.Colour(255, 255, 255))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: AboutFrame.__do_layout
        sizer_6 = wx.BoxSizer(wx.VERTICAL)
        sizer_6.Add((20, 20), 0, 0, 0)
        label_1 = wx.StaticText(self, wx.ID_ANY, "HAND DYNAMOMETER RECOGNITION", style=wx.ALIGN_CENTER)
        label_1.SetFont(wx.Font(24, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift"))
        sizer_6.Add(label_1, 0, wx.EXPAND, 0)
        label_2 = wx.StaticText(self, wx.ID_ANY, "Program pengenalan dan analisis digit karakter LED pada \nElectronic Hand Dynamometer (Model: Camry EH101)\n\nYulianto Candra - 535140021", style=wx.ALIGN_CENTER)
        label_2.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift"))
        sizer_6.Add(label_2, 0, wx.EXPAND | wx.TOP, 10)
        label_3 = wx.StaticText(self, wx.ID_ANY, "-------------------------------------------------------------------\nINFORMASI TOMBOL:\n1. Capture: Untuk Mengambil gambar menggunakan kamera\n2. Open Folder: Untuk membuka lokasi penyimpnan citra input\n3. Recognize: Untuk proses pengenalan\n4. Analyze: Untuk analisa hasil pengenalan menggunakan metode yang telah ditentukan\n-------------------------------------------------------------------\n\nUniversitas Tarumanagara", style=wx.ALIGN_CENTER)
        label_3.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift"))
        sizer_6.Add(label_3, 0, wx.EXPAND | wx.TOP, 10)
        self.SetSizer(sizer_6)
        self.Layout()
        # end wxGlade

# end of class AboutFrame

class DetailFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: DetailFrame.__init__
        kwds["style"] = kwds.get("style", 0) | wx.CAPTION | wx.CLIP_CHILDREN | wx.CLOSE_BOX | wx.SYSTEM_MENU
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((1030, 590))
        self.panel_graph_input = wx.Panel(self, wx.ID_ANY, style=wx.BORDER_SIMPLE)
        self.panel_graph_ref = wx.Panel(self, wx.ID_ANY, style=wx.BORDER_SIMPLE)
        self.normal_record_btn = wx.Button(self, wx.ID_ANY, "Record as Normal Data", style=wx.BORDER_NONE)
        self.normal_abnormal_btn = wx.Button(self, wx.ID_ANY, "Record as Abnormal Data", style=wx.BORDER_NONE)
##        self.detail_method_btn = wx.Button(self, wx.ID_ANY, "Detailed Graph", style=wx.BORDER_NONE)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.rec_as_normal_pressed, self.normal_record_btn)
        self.Bind(wx.EVT_BUTTON, self.rec_as_abnormal_pressed, self.normal_abnormal_btn)
##        self.Bind(wx.EVT_BUTTON, self.detail_mtd_btn_pressed, self.detail_method_btn)

        # MUNCULIN KE PANEL DAN RESIZE
        # BUAT TAMPILIN GRAPH INPUT
        self.bmp = wx.Image('temp/plot_input.jpg', wx.BITMAP_TYPE_JPEG)
        (wp, hp) = self.panel_graph_input.GetSize()
        # SCALE + CONVERT TO BITMAP
        self.bmp = self.bmp.ConvertToBitmap()
        # TARO KE PANEL
        self.obj = wx.StaticBitmap(self.panel_graph_input, -1, self.bmp,(0,0),(wp, hp))
        self.obj.Refresh()

        # BUAT TAMPILIN GRAPH REFERENCE
        self.bmp = wx.Image('temp/plot_reference.jpg', wx.BITMAP_TYPE_JPEG)
        (wp, hp) = self.panel_graph_ref.GetSize()
        # SCALE + CONVERT TO BITMAP
        self.bmp = self.bmp.ConvertToBitmap()
        # TARO KE PANEL
        self.obj = wx.StaticBitmap(self.panel_graph_ref, -1, self.bmp,(0,0),(wp, hp))
        self.obj.Refresh()

    def __set_properties(self):
        # begin wxGlade: DetailFrame.__set_properties
        self.SetTitle("Analysis Result")
        _icon = wx.NullIcon
        _icon.CopyFromBitmap(wx.Bitmap("resources\\analytics_ico.ico", wx.BITMAP_TYPE_ANY))
        self.SetIcon(_icon)
        self.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.panel_graph_input.SetMinSize((492, 369))
        self.panel_graph_input.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.panel_graph_ref.SetMinSize((492, 369))
        self.panel_graph_ref.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.normal_record_btn.SetMinSize((241, 40))
        self.normal_record_btn.SetBackgroundColour(wx.Colour(35, 142, 35))
        self.normal_record_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.normal_record_btn.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        self.normal_abnormal_btn.SetMinSize((241, 40))
        self.normal_abnormal_btn.SetBackgroundColour(wx.Colour(204, 50, 50))
        self.normal_abnormal_btn.SetForegroundColour(wx.Colour(255, 255, 255))
        self.normal_abnormal_btn.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
##        self.detail_method_btn.SetMinSize((492, 40))
##        self.detail_method_btn.SetBackgroundColour(wx.Colour(47, 47, 47))
##        self.detail_method_btn.SetForegroundColour(wx.Colour(255, 255, 255))
##        self.detail_method_btn.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: DetailFrame.__do_layout
        grid_sizer_1 = wx.FlexGridSizer(8, 1, 0, 0)
        sizer_4 = wx.FlexGridSizer(1, 8, 0, 0)
        sizer_11 = wx.FlexGridSizer(1, 10, 0, 0)
        sizer_10 = wx.FlexGridSizer(1, 10, 0, 0)
        sizer_9 = wx.FlexGridSizer(1, 2, 0, 0)
        sizer_7 = wx.FlexGridSizer(1, 5, 0, 0)
        sizer_8 = wx.FlexGridSizer(1, 5, 0, 0)
        grid_sizer_1.Add((20, 10), 0, 0, 0)
        sizer_8.Add((10, 10), 0, 0, 0)
        label_2 = wx.StaticText(self, wx.ID_ANY, "Input Image Graph", style=wx.ALIGN_CENTER)
        label_2.SetMinSize((492, 25))
        label_2.SetFont(wx.Font(14, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_8.Add(label_2, 0, 0, 0)
        sizer_8.Add((10, 10), 0, 0, 0)
        label_3 = wx.StaticText(self, wx.ID_ANY, "Reference Image Graph", style=wx.ALIGN_CENTER)
        label_3.SetMinSize((492, 25))
        label_3.SetFont(wx.Font(14, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_8.Add(label_3, 0, 0, 0)
        sizer_8.Add((10, 10), 0, 0, 0)
        grid_sizer_1.Add(sizer_8, 1, wx.EXPAND, 0)
        sizer_7.Add((10, 10), 0, 0, 0)
        sizer_7.Add(self.panel_graph_input, 1, wx.EXPAND, 0)
        sizer_7.Add((10, 10), 0, 0, 0)
        sizer_7.Add(self.panel_graph_ref, 1, wx.EXPAND, 0)
        sizer_7.Add((10, 10), 0, 0, 0)
        grid_sizer_1.Add(sizer_7, 1, wx.EXPAND, 0)
        sizer_9.Add((10, 10), 0, 0, 0)
        label_4 = wx.StaticText(self, wx.ID_ANY, "RESULT INFORMATION")
        label_4.SetMinSize((492, 22))
        label_4.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_9.Add(label_4, 0, wx.LEFT | wx.TOP, 11)
        grid_sizer_1.Add(sizer_9, 1, wx.EXPAND, 0)
        sizer_10.Add((10, 10), 0, 0, 0)
        label_7 = wx.StaticText(self, wx.ID_ANY, "- Final Threshold")
        label_7.SetMinSize((130, 25))
        label_7.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_10.Add(label_7, 0, wx.ALL, 0)
        label_11 = wx.StaticText(self, wx.ID_ANY, ": ")
        label_11.SetMinSize((5, 25))
        label_11.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_10.Add(label_11, 0, wx.ALL, 0)
        label_threshold = wx.StaticText(self, wx.ID_ANY, result_information['threshold'], style=wx.ALIGN_LEFT)
        label_threshold.SetMinSize((357, 25))
        label_threshold.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_10.Add(label_threshold, 0, 0, 0)
        sizer_10.Add((10, 10), 0, 0, 0)
        label_8 = wx.StaticText(self, wx.ID_ANY, "- Matched Train Data File")
        label_8.SetMinSize((185, 25))
        label_8.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_10.Add(label_8, 0, 0, 0)
        label_12 = wx.StaticText(self, wx.ID_ANY, ": ")
        label_12.SetMinSize((5, 25))
        label_12.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_10.Add(label_12, 0, wx.ALL, 0)
        label_mathed_train_data = wx.StaticText(self, wx.ID_ANY, result_information['file'])
        label_mathed_train_data.SetMinSize((302, 25))
        label_mathed_train_data.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_10.Add(label_mathed_train_data, 0, 0, 0)
        sizer_10.Add((10, 10), 0, 0, 0)
        grid_sizer_1.Add(sizer_10, 1, wx.EXPAND, 0)
        sizer_11.Add((10, 10), 0, 0, 0)
        label_9 = wx.StaticText(self, wx.ID_ANY, "- Result")
        label_9.SetMinSize((130, 25))
        label_9.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_11.Add(label_9, 0, wx.ALL, 0)
        label_13 = wx.StaticText(self, wx.ID_ANY, ": ")
        label_13.SetMinSize((5, 25))
        label_13.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_11.Add(label_13, 0, wx.ALL, 0)
        label_result = wx.StaticText(self, wx.ID_ANY, result_information['result'], style=wx.ALIGN_LEFT)
        label_result.SetMinSize((357, 25))
        label_result.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_11.Add(label_result, 0, 0, 0)
        sizer_11.Add((10, 10), 0, 0, 0)
        label_10 = wx.StaticText(self, wx.ID_ANY, "- File Number")
        label_10.SetMinSize((185, 25))
        label_10.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_11.Add(label_10, 0, 0, 0)
        label_14 = wx.StaticText(self, wx.ID_ANY, ": ")
        label_14.SetMinSize((5, 25))
        label_14.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_11.Add(label_14, 0, wx.ALL, 0)
        label_file_no = wx.StaticText(self, wx.ID_ANY, result_information['no'])
        label_file_no.SetMinSize((302, 25))
        label_file_no.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, 0, "Bahnschrift SemiBold"))
        sizer_11.Add(label_file_no, 0, 0, 0)
        sizer_11.Add((10, 10), 0, 0, 0)
        grid_sizer_1.Add(sizer_11, 1, wx.EXPAND, 0)
        grid_sizer_1.Add((10, 10), 0, 0, 0)
        sizer_4.Add((10, 10), 0, 0, 0)
        sizer_4.Add(self.normal_record_btn, 0, 0, 0)
        sizer_4.Add((10, 10), 0, 0, 0)
        sizer_4.Add(self.normal_abnormal_btn, 0, 0, 0)
        sizer_4.Add((10, 10), 0, 0, 0)
##        sizer_4.Add(self.detail_method_btn, 0, 0, 0)
        sizer_4.Add((10, 10), 0, 0, 0)
        grid_sizer_1.Add(sizer_4, 1, wx.EXPAND, 0)
        self.SetSizer(grid_sizer_1)
        self.Layout()
        # end wxGlade

    def rec_as_normal_pressed(self, event):  # wxGlade: DetailFrame.<event_handler>  
        dlg = wx.MessageDialog(None, "Do you want to save as normal data?",'Record',wx.YES_NO | wx.ICON_QUESTION)
        dlgResult = dlg.ShowModal()
        if dlgResult == wx.ID_YES:
            try:
                ## SAVE OUTPUT SERIES KE normal_test_data AS TRAIN DATA
                with open('trained_data/normal_test_data.txt', 'a') as file:
                    for listitem in result_information['recognition_result']:
                        file.write('%s ' % listitem)
                    file.write('\n')
                # POP UP BOX
                wx.MessageBox(message="Record data berhasil",
                                  caption='Record File',
                                  style=wx.OK | wx.ICON_INFORMATION)
            except:
                wx.MessageBox(message="Record data gagal",
                                  caption='Record File',
                                  style=wx.OK | wx.ICON_INFORMATION)
            

    def rec_as_abnormal_pressed(self, event):  # wxGlade: DetailFrame.<event_handler>
        dlg = wx.MessageDialog(None, "Do you want to save as abnormal data?",'Record',wx.YES_NO | wx.ICON_QUESTION)
        dlgResult = dlg.ShowModal()
        if dlgResult == wx.ID_YES:
            try:
                ## SAVE OUTPUT SERIES KE TEST_DATA AS TRAIN DATA
                with open('trained_data/abnormal_test_data.txt', 'a') as file:
                    for listitem in result_information['recognition_result']:
                        file.write('%s ' % listitem)
                    file.write('\n')
                # POP UP BOX
                wx.MessageBox(message="Record data berhasil",
                                  caption='Record File',
                                  style=wx.OK | wx.ICON_INFORMATION)
            except:
                wx.MessageBox(message="Record data gagal",
                                  caption='Record File',
                                  style=wx.OK | wx.ICON_INFORMATION)

    def detail_mtd_btn_pressed(self, event):
        hist_match_img = cv2.imread('temp\plot_histogram_matching.jpg', 1)
        cv2.imshow("Histogram Matching", hist_match_img)

# end of class DetailFrame

class MyApp(wx.App):
    def OnInit(self):
        self.frame = MainFrame(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame)
        self.frame.Show()
        return True

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
